# Menu and Feature Creation Guidelines

## Overview
This document outlines the standardized process for adding new menus and main features to the Bitcoin Price Alert application.

## Template Structure
1. **Base Layout (`layout.html`)**
   ```html
   {{ block "title" . }}Default Title{{ end }}
   {{ block "content" . }}{{ end }}
   {{ block "scripts" . }}{{ end }}
   ```

2. **Page Template Structure**
   ```html
   {{ define "title" }}Feature Name - Bitcoin Price Alert{{ end }}
   {{ define "content" }}
     <!-- Feature content -->
   {{ end }}
   {{ define "scripts" }}
     <!-- Feature-specific scripts -->
   {{ end }}
   ```

## Component Organization
1. **Partials Location**
   - Place reusable components in `web/templates/partials/`
   - Name format: `feature_component.html` (e.g., `account_summary.html`)

2. **JavaScript Organization**
   - Place feature-specific JS in `web/static/js/feature.js`
   - Use IIFE pattern for scoped functionality
   ```javascript
   (function() {
     // Feature-specific code
   })();
   ```

## Adding a New Menu Item
1. **Update Hamburger Menu**
   ```html
   <a href="/feature" class="side-menu-item">
     <i class="fas fa-icon"></i> Feature Name
   </a>
   ```

2. **Add Route Handler**
   ```go
   func (h *Handler) featurePage(c *gin.Context) {
     c.HTML(http.StatusOK, "layout.html", gin.H{
       "Version": time.Now().Unix(),
       "CurrentPage": "feature",
     })
   }
   ```

3. **Register Templates**
   ```go
   router.LoadHTMLFiles(
     // ... existing templates ...
     "web/templates/feature.html",
     "web/templates/partials/feature_component.html",
   )
   ```

## Feature Implementation Checklist
1. **Frontend Structure**
   - [ ] Create main template extending base layout
   - [ ] Break into logical partials if needed
   - [ ] Add feature-specific styles to `styles.css`
   - [ ] Create feature-specific JavaScript file

2. **Backend Structure**
   - [ ] Add route handler in `handlers.go`
   - [ ] Define necessary API endpoints
   - [ ] Create interfaces in `interfaces/`
   - [ ] Implement services in `adapters/`

3. **Data Flow**
   - [ ] Define data models
   - [ ] Implement repository layer if needed
   - [ ] Add API endpoints for data operations
   - [ ] Implement frontend data fetching

4. **Testing**
   - [ ] Add handler tests
   - [ ] Add service/adapter tests
   - [ ] Add frontend component tests
   - [ ] Test responsive design

## Example: Adding Account Overview Feature

1. **File Structure**
   ```
   web/
     templates/
       account.html              # Main template
       partials/
         account_summary.html    # Balance component
         account_assets.html     # Assets list component
     static/
       js/
         account.js             # Account-specific logic
   internal/
     api/
       handlers.go              # Account routes
     interfaces/
       account_service.go       # Account interfaces
     adapters/
       account_service.go       # Service implementation
   ```

2. **Handler Implementation**
   ```go
   func (h *Handler) accountPage(c *gin.Context) {
     c.HTML(http.StatusOK, "layout.html", gin.H{
       "Version": time.Now().Unix(),
       "CurrentPage": "account",
     })
   }
   ```

3. **Template Example**
   ```html
   {{ define "title" }}Account - Bitcoin Price Alert{{ end }}
   {{ define "content" }}
     {{ template "partials/account_summary" . }}
     {{ template "partials/account_assets" . }}
   {{ end }}
   ```

4. **JavaScript Pattern**
   ```javascript
   // account.js
   (function() {
     const state = {
       balances: null,
       assets: null
     };

     async function initialize() {
       await Promise.all([
         loadBalances(),
         loadAssets()
       ]);
     }

     document.addEventListener('DOMContentLoaded', initialize);
   })();
   ```

## Best Practices
1. **Accessibility**
   - Add ARIA labels to navigation items
   - Ensure keyboard navigation works
   - Maintain proper heading hierarchy

2. **Performance**
   - Lazy load feature-specific JS
   - Use version query params for cache busting
   - Implement loading states

3. **Error Handling**
   - Show user-friendly error messages
   - Implement proper error boundaries
   - Log errors appropriately

4. **State Management**
   - Use module pattern for feature-specific state
   - Implement proper event handling
   - Consider data refresh strategies

## Review Criteria
Before submitting a new menu/feature:
1. **Code Quality**
   - Follows template structure
   - Implements proper error handling
   - Has necessary tests
   - Uses consistent naming conventions

2. **User Experience**
   - Responsive design works
   - Loading states implemented
   - Error states handled gracefully
   - Consistent with app style

3. **Performance**
   - No unnecessary re-renders
   - Proper resource loading
   - Efficient API calls
   - Caching strategy defined

4. **Documentation**
   - Updated API documentation
   - Added usage examples
   - Updated README if needed
   - Added necessary comments
