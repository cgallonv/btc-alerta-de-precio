# Menu and Feature Creation Guidelines

## Overview
This document outlines the standardized process for adding new menus and main features to the Bitcoin Price Alert application.

## Template Structure
1. **Base Layout (`layout.html`)**
   ```html
   <!DOCTYPE html>
   <html lang="es">
   <head>
       <meta charset="UTF-8">
       <meta name="viewport" content="width=device-width, initial-scale=1.0">
       <title>Bitcoin Price Alert - {{.PageTitle}}</title>
       <!-- Common CSS -->
   </head>
   <body>
       {{ template "top_bar" . }}
       {{ template "hamburger_menu" . }}
       <main class="main-content">
           {{ if eq .content "feature_name" }}
               {{ template "feature_name_content" . }}
           {{ end }}
       </main>
       <!-- Common Scripts -->
   </body>
   </html>
   ```

2. **Feature Template Structure (`feature_name.html`)**
   ```html
   {{ define "feature_name_content" }}
   <div class="container mt-4">
       <!-- Feature-specific content -->
   </div>
   {{ end }}
   ```

## Component Organization
1. **Template Naming Convention**
   - Main content template: `feature_name_content`
   - Partial components: `feature_name_component`
   - Example: `alerts_content`, `alerts_form`, `alerts_list`

2. **File Structure**
   ```
   web/
     templates/
       feature_name.html           # Main template
       partials/
         feature_name_component.html
     static/
       js/
         feature_name.js
   ```

## Adding a New Menu Item

1. **Update Layout Template**
   ```html
   <!-- In layout.html -->
   <main class="main-content">
       {{ if eq .content "feature_name" }}
           {{ template "feature_name_content" . }}
       {{ end }}
   </main>
   ```

2. **Create Feature Template**
   ```html
   <!-- web/templates/feature_name.html -->
   {{ define "feature_name_content" }}
   <div class="container mt-4">
       <!-- Feature content -->
   </div>
   {{ end }}
   ```

3. **Update Handler**
   ```go
   func (h *Handler) featureNamePage(c *gin.Context) {
       c.HTML(http.StatusOK, "layout", gin.H{
           "PageTitle": "Feature Name",
           "Version":   time.Now().Unix(),
           "content":   "feature_name",
           // Feature-specific data
       })
   }
   ```

4. **Register Route and Templates**
   ```go
   // In SetupRoutes
   router.GET("/feature-name", h.featureNamePage)

   // Load templates in order
   templ, err = templ.ParseFiles(
       "web/templates/layout.html",
       "web/templates/partials/top_bar.html",
       "web/templates/partials/hamburger_menu.html",
       "web/templates/feature_name.html",
       "web/templates/partials/feature_name_component.html",
   )
   ```

## Feature Implementation Checklist
1. **Template Setup**
   - [ ] Create main template with `feature_name_content` definition
   - [ ] Add feature condition to layout.html
   - [ ] Create necessary partial components
   - [ ] Update template registration in handler

2. **Route and Handler**
   - [ ] Add page handler with proper content identifier
   - [ ] Register route in SetupRoutes
   - [ ] Implement necessary API endpoints
   - [ ] Add proper error handling

3. **Frontend Assets**
   - [ ] Add feature-specific JavaScript
   - [ ] Add feature-specific styles
   - [ ] Update menu items
   - [ ] Add loading states

4. **Testing**
   - [ ] Test template rendering
   - [ ] Test API endpoints
   - [ ] Test responsive design
   - [ ] Test error states

## Example: Adding Settings Feature

1. **Template Structure**
   ```html
   <!-- web/templates/settings.html -->
   {{ define "settings_content" }}
   <div class="container mt-4">
       <div class="row">
           <div class="col-md-4">
               {{ template "settings_menu" . }}
           </div>
           <div class="col-md-8">
               {{ template "settings_form" . }}
           </div>
       </div>
   </div>
   {{ end }}
   ```

2. **Handler Implementation**
   ```go
   func (h *Handler) settingsPage(c *gin.Context) {
       c.HTML(http.StatusOK, "layout", gin.H{
           "PageTitle": "Settings",
           "Version":   time.Now().Unix(),
           "content":   "settings",
           "config":    h.configProvider.GetConfig(),
       })
   }
   ```

3. **Route Registration**
   ```go
   // In SetupRoutes
   router.GET("/settings", h.settingsPage)
   
   // Template registration
   templ, err = templ.ParseFiles(
       // ... existing templates ...
       "web/templates/settings.html",
       "web/templates/partials/settings_menu.html",
       "web/templates/partials/settings_form.html",
   )
   ```

## Handler Implementation Guide

1. **Handler Structure**
   ```go
   // Add to the top of handlers.go if needed
   type FeatureData struct {
       // Feature-specific fields
   }

   // Add handler method
   func (h *Handler) featureNamePage(c *gin.Context) {
       // 1. Get any required data
       data, err := h.someService.GetFeatureData()
       if err != nil {
           log.Printf("Error getting feature data: %v", err)
           c.HTML(http.StatusInternalServerError, "layout", gin.H{
               "error":     "Error loading feature data",
               "PageTitle": "Feature Name",
               "Version":   time.Now().Unix(),
               "content":   "feature_name",
           })
           return
       }

       // 2. Render the page
       c.HTML(http.StatusOK, "layout", gin.H{
           "PageTitle": "Feature Name",
           "Version":   time.Now().Unix(),
           "content":   "feature_name",
           "data":     data,
       })
   }
   ```

2. **Route Registration in SetupRoutes**
   ```go
   func (h *Handler) SetupRoutes(router *gin.Engine) {
       // ... existing routes ...

       // 1. Add page route
       router.GET("/feature-name", h.featureNamePage)

       // 2. If feature needs API endpoints, add them in the api group
       api := router.Group("/api/v1")
       {
           // ... existing API routes ...

           // Feature API endpoints
           api.GET("/feature-name/data", h.getFeatureData)
           api.POST("/feature-name/action", h.performFeatureAction)
       }

       // 3. Register templates in the correct order
       templ := template.New("")
       templ, err = templ.ParseFiles(
           // Base templates first
           "web/templates/layout.html",
           "web/templates/partials/top_bar.html",
           "web/templates/partials/hamburger_menu.html",
           
           // Feature templates
           "web/templates/feature_name.html",
           "web/templates/partials/feature_name_component.html",
           
           // Keep existing templates
           "web/templates/index.html",
           "web/templates/alerts.html",
           // ... other existing templates ...
       )
   }
   ```

3. **API Endpoints Implementation**
   ```go
   func (h *Handler) getFeatureData(c *gin.Context) {
       data, err := h.someService.GetFeatureData()
       if err != nil {
           c.JSON(http.StatusInternalServerError, Response{
               Success: false,
               Error:   err.Error(),
           })
           return
       }

       c.JSON(http.StatusOK, Response{
           Success: true,
           Data:    data,
       })
   }

   func (h *Handler) performFeatureAction(c *gin.Context) {
       var req FeatureRequest
       if err := c.ShouldBindJSON(&req); err != nil {
           c.JSON(http.StatusBadRequest, Response{
               Success: false,
               Error:   err.Error(),
           })
           return
       }

       result, err := h.someService.PerformAction(req)
       if err != nil {
           c.JSON(http.StatusInternalServerError, Response{
               Success: false,
               Error:   err.Error(),
           })
           return
       }

       c.JSON(http.StatusOK, Response{
           Success: true,
           Data:    result,
           Message: "Action performed successfully",
       })
   }
   ```

4. **Handler Dependencies**
   ```go
   // 1. Add new service interface if needed
   type FeatureService interface {
       GetFeatureData() (*FeatureData, error)
       PerformAction(req FeatureRequest) (*FeatureResult, error)
   }

   // 2. Update Handler struct if new dependencies needed
   type Handler struct {
       // ... existing fields ...
       featureService FeatureService
   }

   // 3. Update NewHandler constructor
   func NewHandler(
       alertService interfaces.AlertService,
       configProvider interfaces.ConfigProvider,
       featureService FeatureService,
   ) *Handler {
       return &Handler{
           alertService:   alertService,
           configProvider: configProvider,
           featureService: featureService,
       }
   }
   ```

5. **Error Handling Patterns**
   ```go
   func (h *Handler) featureNamePage(c *gin.Context) {
       // Common error handling pattern for pages
       data, err := h.someService.GetFeatureData()
       if err != nil {
           log.Printf("Error in featureNamePage: %v", err)
           c.HTML(http.StatusInternalServerError, "layout", gin.H{
               "error":     "Unable to load feature. Please try again later.",
               "PageTitle": "Feature Name",
               "Version":   time.Now().Unix(),
               "content":   "feature_name",
           })
           return
       }

       // Success case
       c.HTML(http.StatusOK, "layout", gin.H{
           "PageTitle": "Feature Name",
           "Version":   time.Now().Unix(),
           "content":   "feature_name",
           "data":     data,
       })
   }

   func (h *Handler) apiEndpoint(c *gin.Context) {
       // Common error handling pattern for API endpoints
       result, err := h.someService.DoSomething()
       if err != nil {
           log.Printf("Error in apiEndpoint: %v", err)
           c.JSON(http.StatusInternalServerError, Response{
               Success: false,
               Error:   "An unexpected error occurred",
           })
           return
       }

       c.JSON(http.StatusOK, Response{
           Success: true,
           Data:    result,
       })
   }
   ```

## Best Practices
1. **Template Organization**
   - Use consistent naming: `feature_name_content` for main templates
   - Keep partials in dedicated directory
   - Follow component hierarchy

2. **Handler Structure**
   - Use consistent content identifiers
   - Pass all necessary data in handler
   - Implement proper error handling

3. **Asset Management**
   - Version static assets
   - Organize feature-specific JS/CSS
   - Implement proper caching

4. **Error Handling**
   - Show user-friendly error messages
   - Implement loading states
   - Handle all edge cases

## Review Checklist
Before submitting:
1. **Templates**
   - [ ] Proper template naming
   - [ ] Layout integration
   - [ ] Error states handled
   - [ ] Loading states implemented

2. **Routes**
   - [ ] Handler implemented
   - [ ] Routes registered
   - [ ] Templates loaded
   - [ ] Error handling complete

3. **Assets**
   - [ ] JS/CSS organized
   - [ ] Proper versioning
   - [ ] Loading optimized
   - [ ] Caching implemented

4. **Testing**
   - [ ] Templates tested
   - [ ] Routes tested
   - [ ] Error handling tested
   - [ ] Responsive design verified

## Hamburger Menu Modifications

### Structure Overview
The hamburger menu is a critical navigation component with specific requirements:

1. **Core Components**
   ```html
   <!-- Required Structure -->
   <button id="hamburgerBtn">...</button>
   <div id="sideMenuOverlay">...</div>
   <nav id="sideMenu">
       <div class="d-flex flex-column h-100">
           <div class="p-4 bg-bitcoin">...</div>
           <ul class="nav flex-column mt-3" role="menu">
               <!-- Menu Items Here -->
           </ul>
       </div>
   </nav>
   ```

2. **Adding Menu Items**
   ```html
   <li class="nav-item" role="none">
       <a class="nav-link px-4 py-3{{ if eq .CurrentPage "feature_name" }} active{{ end }}" 
          href="/feature-path" 
          role="menuitem" 
          tabindex="0">
           <i class="fas fa-icon me-2 bitcoin-color" aria-hidden="true"></i> Menu Text
       </a>
   </li>
   ```

### Required Elements
1. **Button Component**
   - Must maintain `id="hamburgerBtn"`
   - Requires ARIA attributes for accessibility
   - Positioned fixed with proper z-index

2. **Overlay Component**
   - Must maintain `id="sideMenuOverlay"`
   - Required for click-outside closing
   - Proper z-index layering

3. **Navigation Component**
   - Must maintain `id="sideMenu"`
   - Proper semantic structure with roles
   - Transition animations

### Accessibility Requirements
1. **ARIA Attributes**
   ```html
   <button aria-label="Abrir menú de navegación" 
           aria-controls="sideMenu" 
           aria-expanded="false">
   ```

2. **Keyboard Navigation**
   - Enter/Space to open menu
   - Escape to close
   - Tab navigation through items
   - Focus management

3. **Semantic Structure**
   - Proper heading hierarchy
   - Role attributes
   - Hidden states

### JavaScript Integration
1. **Required Event Handlers**
   - Click events
   - Keyboard events
   - Focus management
   - State management

2. **Animation Management**
   - Transform transitions
   - Overlay handling
   - Focus trapping

### Example: Adding a New Section
```html
<!-- DON'T DO THIS -->
<div class="side-menu">
    <a href="/feature">
        <i class="fas fa-icon"></i> Feature
    </a>
</div>

<!-- DO THIS -->
<li class="nav-item" role="none">
    <a class="nav-link px-4 py-3{{ if eq .CurrentPage "feature" }} active{{ end }}"
       href="/feature"
       role="menuitem"
       tabindex="0">
        <i class="fas fa-icon me-2 bitcoin-color" aria-hidden="true"></i> Feature
    </a>
</li>
```

### Common Mistakes to Avoid
1. **Structure Breaking**
   - Don't remove the overlay component
   - Don't change IDs of core components
   - Don't simplify the menu structure

2. **Accessibility Breaking**
   - Don't remove ARIA attributes
   - Don't remove role attributes
   - Don't break keyboard navigation

3. **Style Breaking**
   - Don't modify core transition classes
   - Don't change z-index hierarchy
   - Maintain consistent padding/margins

### Testing Checklist
Before committing menu changes:
1. **Functionality**
   - [ ] Menu opens/closes properly
   - [ ] Overlay works correctly
   - [ ] Active states work

2. **Accessibility**
   - [ ] Keyboard navigation works
   - [ ] Screen reader compatibility
   - [ ] Focus management works

3. **Responsiveness**
   - [ ] Works on mobile
   - [ ] Proper transitions
   - [ ] No layout breaking
